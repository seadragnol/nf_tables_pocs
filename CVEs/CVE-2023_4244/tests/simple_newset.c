#define _GNU_SOURCE

#include <errno.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/set.h>
#include <libnftnl/table.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <assert.h>
#include <inttypes.h>
#include <pthread.h>

#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <arpa/inet.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) fprintf(stderr, "[-] %s:%d: %s: %s\n", __func__, __LINE__, msg, strerror(errno))

struct list_head {
    struct list_head *next, *prev;
};

struct rhash_head {
    struct rhash_head* next;
};

struct rhlist_head {
    struct rhash_head rhead;
    struct rhlist_head* next;
};

struct msg_msgseg {
    struct msg_msgseg* next;
};

struct nft_expr {
    struct nft_expr_ops* ops;
    unsigned char data[]
        __attribute__((aligned(__alignof__(uint64_t))));
};

struct nft_rule {
    struct list_head list;
    uint64_t handle : 42,
        genmask : 2,
        dlen : 12,
        udata : 1;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_dp {
    uint64_t is_last : 1,
        dlen : 12,
        handle : 42; /* for tracing */
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_expr))));
};

struct nft_rule_blob {
    unsigned long size;
    unsigned char data[]
        __attribute__((aligned(__alignof__(struct nft_rule_dp))));
};

struct nft_chain {
    struct nft_rule_blob* blob_gen_0;
    struct nft_rule_blob* blob_gen_1;
    struct list_head rules;
    struct list_head list;
    struct rhlist_head rhlhead;
    struct nft_table* table;
    uint64_t handle;
    uint32_t use;
    uint8_t flags : 5,
        bound : 1,
        genmask : 2;
    char* name;
    uint16_t udlen;
    uint8_t* udata;

    /* Only used during control plane commit phase: */
    struct nft_rule_blob* blob_next;
};

struct nft_userdata {
    uint8_t len;
    unsigned char data[];
};

typedef struct mnl_socket* sock;
typedef struct mnl_nlmsg_batch* batch;
typedef struct nlmsghdr* nlmsghdr;
typedef struct nftnl_table* table;
typedef struct nftnl_set* set;
typedef struct nftnl_chain* chain;
typedef struct nftnl_rule* rule;
typedef struct nftnl_expr* expr;

static sock nlsock;
static const uint16_t family = NFPROTO_IPV4;
static uint32_t seq = 1, rseq = 1;

char* table_name = "test_table";
char* chain_name_1 = "test_chain_1";
char* chain_name_2 = "test_chain_2";

void write_to_file(const char* which, const char* format, ...)
{
    FILE* fu = fopen(which, "w");
    va_list args;
    va_start(args, format);
    if (vfprintf(fu, format, args) < 0) {
        ERROR("cannot write");
        exit(1);
    }
    fclose(fu);
}

int setup(void)
{
    uid_t uid = getuid();
    gid_t gid = getgid();

    // In order to use nf_tables, we need CAP_NET_ADMIN
    INFO("Setting up user namespace");

    if (unshare(CLONE_NEWUSER | CLONE_NEWNET)) {
        ERROR("unshare(CLONE_NEWUSER | CLONE_NEWNET)");
        return -1;
    }

    // Pin process to a single CPU to avoid nf_tables allocations to spill over different slabs
    INFO("Pinning process to CPU #0");

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
        perror("[-] sched_setaffinity");
        return -1;
    }

    // now we map uid and gid
    write_to_file("/proc/self/uid_map", "0 %d 1", uid);
    // deny setgroups (see user_namespaces(7))
    write_to_file("/proc/self/setgroups", "deny");
    // remap gid
    write_to_file("/proc/self/gid_map", "0 %d 1", gid);

    INFO("Creating netfilter netlink socket");
    if ((nlsock = mnl_socket_open(NETLINK_NETFILTER)) == NULL) {
        ERROR("mnl_socket_open(NETLINK_NETFILTER)");
        return -1;
    }

    return 0;
}

static table make_table(const char* name, const void* udata, uint32_t udlen)
{
    table t = nftnl_table_alloc();
    if (t == NULL) {
        ERROR("Couldn't allocate a table");
        exit(EXIT_FAILURE);
    }

    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);

    if (udata != NULL && udlen > 0)
        nftnl_table_set_data(t, NFTNL_TABLE_USERDATA, udata, udlen);

    return t;
}

static set make_set(const char* table, const char* name, uint32_t flags) {
    set s = nftnl_set_alloc();
    if (s == NULL) {
        ERROR("Couldn't allocate a set");
        exit(EXIT_FAILURE);
    }

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
	nftnl_set_set_str(s, NFTNL_SET_NAME, name);
	nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
	nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, sizeof(uint16_t));
	/* inet service type, see nftables/include/datatypes.h */
	nftnl_set_set_u32(s, NFTNL_SET_KEY_TYPE, 13);
	nftnl_set_set_u32(s, NFTNL_SET_ID, 1);

    return s;
}

// static chain make_chain(const char* table, const char* name, uint32_t flags, int hooknum, int prio)
static chain make_chain(const char* table, const char* name, uint32_t flags)
{
    chain c = nftnl_chain_alloc();
    if (c == NULL) {
        ERROR("Couldn't allocate a chain");
        exit(EXIT_FAILURE);
    }

    nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table);
    nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, name);
    nftnl_chain_set_u32(c, NFTNL_CHAIN_FLAGS, flags);

    // // make base chain
    // if (hooknum != 0) {
    //     nftnl_chain_set_u32(c, NFTNL_CHAIN_HOOKNUM, hooknum);
    //     nftnl_chain_set_u32(c, NFTNL_CHAIN_PRIO, prio);
    // }

    return c;
}

static rule make_rule(const char* table, const char* chain, expr* exprs, size_t num_exprs, const void* udata, uint32_t udlen, uint64_t handle)
{
    rule r = nftnl_rule_alloc();
    if (r == NULL) {
        ERROR("Couldn't allocate a rule");
        return NULL;
    }

    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);

    for (int i = 0; i < num_exprs; ++i)
        nftnl_rule_add_expr(r, exprs[i]);

    if (udlen > 0)
        nftnl_rule_set_data(r, NFTNL_RULE_USERDATA, udata, udlen);

    if (handle > 0)
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, handle);

    return r;
}

static expr make_immediate_jump_expr(const char* target_chain)
{
    expr e = nftnl_expr_alloc("immediate");
    if (e == NULL)
        return NULL;

    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_JUMP);
    nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, target_chain);

    return e;
}

static expr make_notrack_expr()
{
    return nftnl_expr_alloc("notrack");
}

static batch batch_init(size_t size)
{
    void* buf = malloc(size);
    batch b = mnl_nlmsg_batch_start(buf, size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;
    return b;
}

static void batch_end(batch b)
{
    nftnl_batch_end(mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);
}

static ssize_t batch_send(batch b, sock s)
{
    return mnl_socket_sendto(s, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
}

static void batch_free(batch b)
{
    void* buf = mnl_nlmsg_batch_head(b);
    mnl_nlmsg_batch_stop(b);
    free(buf);
}

static void batch_new_table(batch b, table t)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWTABLE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_table_nlmsg_build_payload(hdr, t);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_set(batch b, set s)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWSET, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_set_nlmsg_build_payload(hdr, s);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_chain(batch b, chain c)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELCHAIN, family, NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c);
    mnl_nlmsg_batch_next(b);
}

static void batch_new_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, family, NLM_F_ACK | NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static void batch_del_rule(batch b, rule r)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr((char*)mnl_nlmsg_batch_current(b), NFT_MSG_DELRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);
}

static nlmsghdr dump_rule(rule r, char* buf)
{
    nlmsghdr hdr = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    return hdr;
}

static int run_callbacks(sock s, mnl_cb_t cb, void* data)
{
    // INFO("Start callback: rseq = %d, seq = %d", rseq, seq);
    char buf[MNL_SOCKET_BUFFER_SIZE];
    int ret = 0;
    while (rseq < seq) {
        ret = mnl_socket_recvfrom(s, buf, sizeof(buf));
        if (ret <= 0)
            break;
        ret = mnl_cb_run(buf, ret, rseq, mnl_socket_get_portid(s), cb, data);
        if (ret < 0)
            break;
        rseq += ret == 0;
    }
    // INFO("End callback: rseq = %d, seq = %d", rseq, seq);
    return ret;
}

static int netfilter()
{
    INFO("Test nf_tables set");
    table t = make_table(table_name, NULL, 0);
    set s = make_set(table_name, "test_set", 0);

    batch b = batch_init(MNL_SOCKET_BUFFER_SIZE * 2);
    batch_new_table(b, t);
    batch_new_set(b, s);

    batch_end(b);
    if (batch_send(b, nlsock) == -1) {
        ERROR("batch_send");
        return -1;
    }
    batch_free(b);
    if (run_callbacks(nlsock, NULL, NULL) < 0) {
        ERROR("run_callbacks");
        return -1;
    }

    return 0;
}


int main()
{
    if (setup() == -1)
        return -1;
    // system("ip link set dev lo up"); // setting the loopback up

    netfilter();

    system("/bin/bash");

    return 0;
}